#pragma once

/*
* —труктурв Tree содержит одно поле типа int, где хранитс€ разность числа узлов (левый-правый),
* три пременные типа Tree_t* - указатели на левого и правого потомков и указатель на предка.
*/
typedef struct Tree_t {
	int node_diff;
	struct Tree_t* left;
	struct Tree_t* right; 
	struct Tree_t* parent;
} Tree;

/*
* AddLeafToTree:
* ‘ункци€ добавлени€ листа в дерево.
* Ќа вход получает переменную типа Tree** - исходное дерево, в которое необходимо добавить лист.
* ѕо€снение работы функции:
* ≈сли дерево пустое, то создаем новый лист и он же становитс€ корнем этого дерева;
* ¬ противном случае, идем в цикле пока правый и левый потомок не будут отсутствовать, 
* внутри цикла делаем проверку на остутствие левого/правого листа, 
* если находим такой узел, то добавл€ем новый лист влево/вправо соответственно и увеличиваем/уменьшаем разность числа узлов.
* ≈сли же цикл заканчиваетс€, наткнувшись на лист (отсутствие обоих потомков), то добавл€ем лист влево и увеличиваем разрость.
*/
void AddLeafToTree(Tree** tree);

/*
* DeleteLeafFromTree:
* ‘ункци€ удалени€ самого дальнего листа из дерева.
* Ќа вход получает переменную типа Tree** - исходное дерево, из которого необходимо удалить лист.
* ѕо€снение работы функции:
* Ќаходим дальнейший лист и удал€ем его, если таких листов несколько, удал€ем левый.
*/
void DeleteLeafFromTree(Tree** tree);

/*
* PrintTree_CenteredBypass:
* ‘ункци€ вывода дерева на экран с помощью центрированного обхода.
* Ќа вход получает переменную типа Tree** - дерево дл€ вывода.
*/
void PrintTree_CenteredBypass(Tree* tree);