#pragma once

/*
* структура Point содержит поля х и у int - координаты одной вершины многоугольника на плоскости
*/
typedef struct {
	int x;
	int y;
} Point;

/*
* структура List содержит поля point и next типа Point* и List_t* - текущаа точка и указатель на следующее поле списка
*/
typedef struct List_t {
	Point* point;
	struct List_t* next;
} List;

/*
* функция RoundDown округляет значение вниз до целого
* на вход поступает double r
* возвращается int R
*/
int RoundDown(double r);

/*
* функция InsertToList втавляет точку в конец списка
* на вод поступают Point* point - точка и  List** list - указатель на исходный список
* значение не возвращается, меняется сам  List** list
*/
void InsertToList(Point* point, List** list);

/*
* функция CreateListFromFile собирает из файла все координаты точек и записывает их в список
* на вход поступает название файла char const* filename
* возвращается заполненный список типа List*
* в файле все точки идут друг за другом в порядке обхода вершин многоугольника - против часовой стрелки 
*/
List* CreateListFromFile(char const* filename);

/*
* функция CreateListField создает поле списка
* на вход поступают int x и int y - координаты точки на плоскости
* возвращается значение типа List* - указатель на заполненную ячейку списка
*/
List* CreateListField(int x, int y);

/*
* функция Min ищет минимальное значение в спике по заданной оси
* на вход поступают List* dots - список, в котором лежат координаты точек;
* int flag_x и int flag_y - 0 или 1 в зависимости от оси по которой ищем минимум
* возвращается значение типа int - минимум значения координаты по заданной оси 
*/
int Min(List* dots, int flag_x, int flag_y);

/*
* функция Max ищет минимальное значение в спике по заданной оси
* на вход поступают List* dots - список, в котором лежат координаты точек;
* int flag_x и int flag_y - 0 или 1 в зависимости от оси по которой ищем максимум
* возвращается значение типа int - максимум значения координаты по заданной оси
*/
int Max(List* dots, int flag_x, int flag_y);

/*
* функция FormArray создает двумерный динамический массив нужного размера
* на вход поступает List* dots - список точек
* возвращается массив типа List** (указатель на список элементов типа List*)
* (нам нужно создать массив координат по игреку, в ячейках которого будут лежать списки с координатами пересечений игреков с границами заданной фигуры
* создадим массив размера разницы минимального и максимального значений по игреку)
*/
List** FormArray(List* dots);

/*
* функция InsertPointToArray добавляет в массив поле списка
* на вход поступают List** Array - массив списков
* int x и int y - координаты точки
* List* dots - массив всех точек. Нужен для функции поиска минимального значения:
* точка с координатами х и у должна быть записана в ячейку Array с инндексом у, однако если не выполнится сдвиг
* на разницу между у и минимальным значением по оси у, получим переполнение массива списков, т.к он создается с 0 
* значение не возвращается, меняется сам массив
*/
void InsertPointToArray(List** Array, int x, int y, List* dots);

/*
* функция InsertToArray по двум точкам считает уравнение прямой и по заданному зачению игрека добавляет в соответствующее поле массива элемент списка с точкой пересечения
* на вход поступают List** Array - массив списков
* Point* point1 и Point* point2 - координаты двух соседник точек
* List* dots - массив всех точек
* по построенному уравнению прямой вычисляется коэффициент наклона прямой
* в зависимости от полученного значения в цикле берутся значения по иксу/игреку из промежутка между координатами точек point1 и point2
* и вычисляются соответствующие значения по игреку/иксу 
* выполняется добавление точки в нужную ячейку массива Array с помощью функции InsertPointToArray
* 
*/
void InsertToArray(Point* point1, Point* point2, List** Array, List* dots);

/*
* функция CreateArray создает двумерный динамический массив заполненный ноликами
* на вход поступают размеры массива
* возвращается указатель на созданный массив
*/
int** CreateArray(int n, int m);

/*
* функция FreeArray чистит памаять, выделенную под двумерный динамический массив
* на вход поступают указатель намассив, который нужно очистить - int** Array и размер поодной из сторон - int n
* значение не возвращается
*/
void FreeArray(int** Array, int n);

/*
* функция FillingMatrix заполняет массив с заполненными 1 в клетках, находящихся на границах многоугольника единичками 
* на вход поступают int** Matrix - массив из 1 и 0,
* int n, int m - размеры массива
* в циклах мы последовательно проходимся во все стороны по ячейкам массива до тех пор, пока не встречается 1 
* первое вхождение 1 от рассматриваемой точки означает границу
* ячейка матрицы должна стать 1, если со всех сторон окружена 1 (находится внутри многоугольника)
*/
void FillingMatrix(int** Matrix, int n, int m);

/*
* функция PrintMatrix выводит на экран готовую матрицу из 1 и 0
* на вход подается int** Matrix - матрица для вывода
* int n, int m - размеры матрицы
*/
void PrintMatrix(int** Matrix, int n, int m);

/*
* функция CompleteMatrix в массиве из 0 меняет на 1 ячейки соответствующие координатам пересечения границ многоугольника
* на вход поступают List** Array - массив списков, List* dots - массив точек (для вычисления границ заполнения)
* значение не возвращается
* проходит по всем элементам списков, лежащих в ячейках List** Array, и в соответствующих ячейках массива из ноликов, меняет значения на 1
*/
void CompleteMatrix(List** Array, List* dots);
