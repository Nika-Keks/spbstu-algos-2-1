#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <locale.h>
#include < string.h >
#include <windows.h>
#include < string.h >
#pragma warning (disable:4996)
#define N 20

typedef struct _Node {//структура для
	char* name;//наименование товара
	long int art, cost;//артикул и стоимость товара
	struct _Node* next;//следующий элемент списка
	struct _Node* prev;//предыдущий элемент списка
} Node;

typedef struct _List {//для хранения ссылок на первый и последний элементы списка
	Node* head;//ссылка на первый элемент
	Node* tail;//ссылка на хвост списка
} list;

list* createList() {//создаём двусвязную структуру
	list* tmp = (list*)malloc(sizeof(list));//выделяем динамическую память
	if (tmp != NULL)//если выделение памяти успешно
	{
		tmp->head = tmp->tail = NULL;//первый и последний элементы определяем как нулевые элементы
	}
	else
	{
		printf("Ошибка выделения памяти");
	}
	
	return tmp;
}

void ListDestroy(list** list) {//удаление списка
	Node* tmp = (*list)->tail;//приравниваем к последнему элементу списка
	Node* prev = NULL;
	while (tmp!=NULL) {
		prev = tmp->prev;//переход к предыдущему элементу 
		free(tmp);//очищаем элемент
		tmp = prev;
	}
	free(*list);//очищаем весь список
	(*list) = NULL;
}
void pushback(list** he, Node* q)//добавление в конец списка или (после элемента списка)
{
	q->prev = (*he)->tail;//предыдущий элемент перед записываемым будет хвост списка
	if ((*he)->tail!=NULL) {//проверяем, что хвост не нулевой
		(*he)->tail->next = q;//следующий после хвоста элемент-это тот, который хотим добавить
	}
	(*he)->tail = q;//теперь конец списка это наш вставной элемент q

	if ((*he)->head == NULL) {//если голова нулевая (нет элементов), то список будет ссылаться на наш последний элемент q
		(*he)->head = q;//если не было элементов, то голова ссылается на вставной нами элемент
	}
}
void pushfo(list** he, Node*q) //добавление в начало список 
{
	q->next = (*he)->head;//следующий за вставным элементом, это бывший первый элемент списка
	if ((*he)->head!=NULL) {//если уже существует элемент в начале списка
		(*he)->head->prev = q;//предыдущим элементом для бывшего первого элемента будет наш вставной элемент q
	}
	(*he)->head = q;//теперь голова списка это наш вставной элемент q
	if ((*he)->tail == NULL) {//Если хвост был пустой, то делаем ссылку на наш записываемый элемент
		(*he)->tail = q;//теперь последний элемент-это наш вставной элемент
	}
}

void pushbefore(list** lis, Node* em, Node*q) {//вставка до указанного элемента em, на вход поступает список, элемент em , перед которым производится вставка и вставной элемент q
	if (!em->prev) {//если ссылка узла на предудущий элемент нулевая, перед которым нужно вставить элемент, , 
		list * loc = *lis;
		pushfo(&loc, q);
		return;//выходим из функции
	}
		q->prev = em->prev;//элемент перед вставным элементом q, будет элементом, который предшедствует элементу em, перед которым производится вставка
		em->prev->next = q;//теперь элемент предшедствующий элементу em ссылается на вставной элемент q
		q->next = em;//вставной элемент q ссылается на элемент em
		em->prev = q;//теперь элемент предшедствующий элементу em это вставной элемент q
}
int Error(list** tmp1, Node* q)//Проверка на разность артикулов у разных названий, на вход функции передаётся список и элемент, который нужно вставить
{
	Node* tmp = (*tmp1)->head;//инициализируем tmp как первый элемент всего списка
	list* he = *tmp1;
	do{
		if ((tmp->art == (q->art)) && (strcmp(tmp->name, q->name) != 0))//если артикулы равны, но названия разные вывести об ошибке
		{
			printf("Ошибка: одинаковый артикул, но разное наименование товара");
			return -1;
		}
		tmp = tmp->next;//переход к следующему элементу
	} while (tmp != NULL);//проходим по всему списку
	return 0;
}
int SortCost(list** tmp1, Node*q)//сортировка по цене q-это элемент который нужно внести в список, tmp1-список, в который нужно записать элемент
{
	Node* tmp = (*tmp1)->head;//инициализируем tmp как первый элемент всего списка
	list* he = *tmp1;//для правильной работы функций вставки
	while (((tmp->cost) > (q->cost)) && (tmp->next != NULL)) //проверка на то что стоимость текущего элемента меньше или нет стоимостью считываемого из списка элемента, также условие что не конец списка и чтобы артикулы не были равны
	{
		tmp = tmp->next;//переход к следующему элементу списка
	}
	if (((tmp->cost) > q->cost))//если стоимость меньше стоимости товара из списка, если это условие выполняется после цикла, то значит пришли к концу списка 
	{
		if (he->tail == tmp) pushback(&he, q);//если элемент tmp списка является концом списка, то вставка в конец списка
		else pushbefore(&he, tmp->next, q);//если же не является концом списка, то добавляем перед элементом следующим за tmp элемент q
	}
	else if (tmp->cost < q->cost)//стоимость товара больше стоимости элемента из списка, но этот элемент не первый
	{
		pushbefore(&he,tmp,q);//запись перед элементом tmp элемента q
	}
	else if (tmp->cost == q->cost)//если стоимоти равны, то сортировка по артикулу
	{
		if ( SortArt(&he,tmp, q)==0)
		{
			return 0;
		}
		else return -1;
	}
	return 0;
}
int SortArt(list** tmp1, Node* tmp, Node* q)//сортировка по артикулу q-это элемент который нужно внести в список
{
	int k = 0;
	list* he = *tmp1;
	while (((tmp->art) > (q->art))&&(tmp->cost == q->cost) && (tmp != he->tail))//цикл выполняется для товаров с одинаковой стоимостью, пока артикул товара из списка больше артикула вставляемого элемента
	{
		tmp = tmp->next;
	}
	
	if ((tmp->cost != q->cost)|| (tmp->art) < (q->art))//если цикл завершился по причине не равенства стоимостей или если артикул элемента из списка меньше артикула добавляемого элемента
	{
		pushbefore(&he,tmp,q);//запись перед элементом tmp элемента q
	}
	else if (he->tail == tmp) pushback(&he, q);//если цикл завершился по причине того, что последний элемент из списка имеет ту же стоимост, что и вставляемый элемент
	return 0;
}
int Sort(list**head, char* v, long int a,long int l)//функция сортировки. head-список, в который записывается элемент, v-наименование товара записываемого элемента, a-артикул, l-стоимость товара
{
	list* tmp = *head;
	Node* q = (Node*)malloc(sizeof(Node));//выделяем память под записываемый элемент
	if (q != NULL)
	{
		q->prev = NULL;//заполняем структуру элемента, которого надо втавить
		q->next = NULL;
		q->name = v;//наименование товара
		q->art = a;//артикул товара
		q->cost = l;//стоимость товара
		if (tmp->head== NULL)
		{
			pushback(&tmp, q);//если в голове списка нет элементов(значит в списке пока нет элементов, вызываем функцию вставки в конец списка
			return 0;
		}
		else
		{
			if (Error(&tmp, q) == 0)//сначала проверяем, что с артикулом полученного товара нет другого товара с таким же артикулом, но лругим названием
			{
				if (SortCost(&tmp, q) == 0)//вызываем функцию сортировки по стоимости
				{
					return 0;
				}
				else return -1;
			}
			else return -1;
			
		}
		
	}
	else
	{
		printf("Ошибка выделения памяти");
		return -1;
	}
	return 0;
}
int ReadText(list** head, char* filename)//функция чтения из файла
{
	char* i = (char*)malloc(N * sizeof(char));//инициализация для названия
	if (i == NULL)
	{
		printf("Ошибка выделения памяти");
		return -1;
	}
	long int j, l;
	// определяем указатель на файл
	FILE* fin;
	// открываем файл на чтение
	fopen_s(&fin, filename, "r");
	if (fin == NULL)
	{
		printf("Не удалось открыть файл");
		return -1;
	}
	while (fscanf(fin, "%s%ld%ld", i, &j, &l) != EOF)//считываем построчно файл
	{
		if (Sort(head, i, j, l) == -1)//вызываем функцию сортировки
		{
			return -1;//Если вернулся не 0, то значит произошли ошибки
		}
		i = (char*)malloc(N * sizeof(char));//инициализация для названия
		if (i == NULL)
		{
			printf("Ошибка выделения памяти");
			return -1;
		}
	}
	fclose(fin);
	return 0;
}
void Serch(list** he,long int cost)//поиск по списку по заданной стоимости
{
	Node* k = (* he)->head;
	int m=0;//количество совпадений введённой стоимости со стоимостями из списка
	if (cost == 0)
	{
		printf("Вы закончили поиск\n");
		return;
	}
	if (k != NULL)
	{
		do {
		if (k->cost == cost)
		{
			m++;//увеличиваем количество совпадений
			printf("Найденный товар: %s %ld %ld\n", k->name, k->art, k->cost);
			k = k->next;//переходим к следующему элементу списка
		}
		else
		{
			k = k->next;//переходим к следующему элементу списка
		}
		} while ((k != NULL));//пока не конец файла
		if (m==0) printf("К сожалению товар с такой стоимость не найден, если хотите завершить поиск наберите 0\n");//не нашлось совпадений
		else printf("Если хотите завершить поиск наберите 0\n");
	}
}
void Print(list** he)//Для вывода и поиска
{
	int len = 1;
	long int cost;
	Node* k = (*he)->head;//выделяем память для списка, который будет изменяться по мере вывода на экран элементов из списка
	printf("10 товаров с самой высокой ценой:\n");
	do {
		printf("%d: %s %ld %ld\n", len, k->name, k->art, k->cost);
		k = k->next; // переход к следующему узлу
		len++;//увеличиваем число выведенных элементов
	} while (len != 11);
	printf("Поиск товара со стоимостью:\n");
	do {

		printf("Пожалуйста введите стоимость товара:\n");
		scanf_s("%ld", &cost);//вводим стоимость с клавиатуры
		Serch(he, cost);//вызываем функцию поиска, на вход идёт список и стоимость, с которой надо сравнивать стоимости из списка

	} while (cost != 0);
	ListDestroy(he);//loc и he связаны, поэтому отчишая одного мы очищаем обоих сразу
}
int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	char* NAMETXT = "list.txt";//наименования файла для считывания
	list* he = createList();
	if (ReadText(&he, NAMETXT) == 0)//Если чтение успешно
	{
		Print(&he);
	}
	else
	{
		ListDestroy(&he);
		return -1;
	}
	return 0;
}